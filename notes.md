# メモ

## gccでの分割コンパイル
1. それぞれのソースファイルからオブジェクトファイルを作成
    - ```gcc -c matrix.c```
    - ```gcc -c multiple_matrix.c```
    - それぞれのオブジェクトファイル（.o）が作成される
    - ```-c```は、リンクせずにコンパイルするオプション. 機械語への翻訳まで.
2. リンクする
    - ```gcc multiple_matrix.o matrix.o -o multiple_matrix```
    - これで実行ファイルが作成される


## Makefileについて
- make を使うとまとめてコンパイルできるので便利
- Makefile の記述方法はいまいちよくわかっていないが、大まかに変数を定義する部分と、コマンドを実行する部分に別れている模様. 以下は、ドキュメント等で確認した訳ではないが、こんな感じの挙動だと推察したもの.
- よく使われる変数
    - CC: コンパイラ. gccを使いたいなら、```CC = gcc```
    - SRCS: ソースファイル. ```SRCS = matrix.c multiple_matrix.c```のように複数書ける. 改行させたいときは\をつかう.
    - OBJS: オブジェクトファイル. 通常、オブジェクトファイルの名前はソースファイル名の.cを.oに置き換えたものなので、```${SRCS:.c=.o}```のように書く.
    - CFLAGS: コンパイル時のオプション.
    - TARGET: できあがりの実行ファイル名. 
- Makefile の"ルール"
    - このルールを実行することによってコンパイルを自動化する
    - ルールの書式は次のとおり. recipeの前はタブ. **タブで無いとrecipeと認識しない**.
        ```
        target: prerequisites
            recipe
        ```
        - target: ルールによって生成されるファイル名、makeコマンドのオプションにもなる.
        - prerequisites: ルールを実行するにあたって、必要となるもの 
        - recipe: 実行するコマンド
    - ターミナル上で```make```と実行するだけだと、targetがallのルールが実行される
    - $(SRCS)や$(OBJS)は、単一のファイルとは限らず、定義されたときのすべてのファイルを指すものっぽい.
        - ```$(TARGET): $(OBJS)```は、```multiple_matrix: matrix.o multiple_matrix.o```のように展開される.
        - ```$(CC) $(CFLAGS) -o $(TARGET) $(OBJS)```は```gcc -Wall -o multiple_matrix matrix.o multiple_matrix.o```のように展開される.
    - prerequisitesがまだ生成されていない場合は、prerequisitesがtargetとなっているルールを先に実行する.
        - 「all: $(TARGET)」のルール => まだ$(TARGET)がないので「$(TARGET): $(OBJS)」のルール => まだ、$(OBJS)がないので「%.o: %.c matrix.h」のルール...という順番っぽい
            - %.o: %.c の部分は一対のオブジェクトファイルとソースファイルをワイルドカード的に表していて、「matrix.o: matrix.c」あるいは「multiple_matrix.o: multiple_matrix.c」のような意味だと思われる.
            - ```$<```はprerequisitesの最も左側にあるファイル、```$@```はtarget名に展開されるらしい. つまり、targetとprerequisitesが```matrix.o: matrix.c matrix.h```のとき、recipeである```$(CC) $(CFLAGS) -c $< -o $@```は```gcc -Wall -c matrix.c -o matrix.o```のように展開され、このルールにおけるtargetでもあるオブジェクトファイルが生成される.
    - 「clean:」ルールは、prerequisitesが無く、recipeが書かれているだけである. targetはmakeコマンドのオプションにもなるので、ターミナル上で```make clean```とすれば、```rm -f $(OBJS) $(TARGET)```というrecipe、すなわち、コマンドが実行される. 
        - このとき、$(OBJS)や$(TARGET)は、prerequisitesに入っている訳ではないので、これらが生成されるレシピが実行されることはなく、単にコマンド内の変数が置換されてrmコマンドが実行される.


## ヘッダファイルについて
- includeでの囲み方
    - システムに用意されているヘッダファイルは< >で囲む
    - 自作のヘッダファイルは" "で囲む
- ヘッダファイルに書く内容
    1. **多重インクルードのガード**
        - #ifndef SOMETHING_H と #define SOMETHING_H
            - SOMETHING_Hが定義されていない場合、#endifまでの区間を実行する. その間に、SOMETHING_Hを定義する.
            - SOMETHING_Hが定義されている場合、#endifまでスキップする. 
            - つまり、一度定義されているなら二度目は実行しないので、二重定義を防げる
            - #ifndef と #define の後ろは全く同じものでないとダメ.
    1. 通常のインクルード
    1. マクロ定義
    1. 型の定義
    1. プロトタイプ宣言
    1. #ifndef を閉じるための #endif
- ヘッダファイル内にプロトタイプ宣言があり、これをインクルードすることで、実際の関数の記述がなくても型のチェックが行える. ゆえに、**ソースファイルごとに分割コンパイルを行うことができる**.

## メモリの動的確保
- 配列のためのスペースはスタックに確保される. これは予めサイズが決まっていないといけない. したがって、配列の大きさは実行時に変更することはできず、それゆえ、配列のサイズ指定に変数を用いることはできない
- malloc()やcalloc()を使うことで、動的にメモリを確保し、動的にサイズを変更できる配列のようなものを実現することができる
- malloc()を使う手順
    1. ```int *p = (int *)malloc( sizeof(int) * num);```のように、引数に確保するメモリのサイズを入れる. これで、ポイント先のアドレスと、割り当てられるメモリのサイズが決定する
    1. **malloc()がNULLを返すかもしれないのでチェックする**.
    1. 割り当てられたメモリを初期化する. memset()が便利.
    1. 作業
    1. **free()で割り当てられたメモリを開放する**.
    1. ```p = NULL;```として、使っていたポインタ変数にNULLを代入. => freeでメモリを開放してもポイント先のアドレス情報は残存しているので、これをしないと、誤って開放したメモリにアクセスするかもしれない.

